[
{
	"uri": "https://postgres.rest/getting-started/",
	"title": "Getting Started",
	"tags": [],
	"description": "",
	"content": " Getting Started There\u0026rsquo;s mainly two ways to start with pREST, either you already have a database that you want to make an API to or you are starting with a totally new database from scratch.\n"
},
{
	"uri": "https://postgres.rest/",
	"title": "Welcome",
	"tags": [],
	"description": "",
	"content": " What is pREST? pREST is a way to serve a RESTful APIs for any database. Right now we support PostgreSQL and support to others databases such as MySQL are being developed by the community.\nProblem There is PostgREST written in Haskell, but keeping Haskell software in production is not an easy job. With this need pREST was born.\nRead more.\nDatabases supported  PostgreSQL  9.4 or higher  MySQL (development)  Supported Operating system  Linux  i386 AMD 64 ARM 5 ARM 6 ARM 7 ARM 64 MIPS MIPS 64 MIPS LE MIPS 64 LE  macOS  i386 AMD 64  Windows  i386 AMD 64  BSD (we need your help)  Versions  lastest (developer) 0.3.0 (latest stable release)  "
},
{
	"uri": "https://postgres.rest/getting-started/installation/",
	"title": "Installation",
	"tags": [],
	"description": "",
	"content": " Here are all the ways you can install pREST, choose one that best fits your needs.\nIndex  Downloading the binary With Docker Using go get With Homebrew  Downloading the binary For any OS you can download the latest version here.\nWith Docker We only will need to download the pREST image from Docker Hub with:\ndocker pull prest/prest  Using go get go get -u github.com/prest/prest  With Homebrew If none of the above suits you, there\u0026rsquo;s still an option of installing using Homebrew\nbrew install prest  "
},
{
	"uri": "https://postgres.rest/getting-started/running/",
	"title": "Running",
	"tags": [],
	"description": "",
	"content": " Running Now that you installed pREST, you have a choice. Either run it with a pre-existing database or with a new one:\n With a new database Already have a database  "
},
{
	"uri": "https://postgres.rest/configurations/",
	"title": "Configurations",
	"tags": [],
	"description": "",
	"content": " Via environment variables or via toml file.\nEnvironment vars  PREST_HTTP_PORT (default 3000) PREST_PG_HOST (default 127.0.0.1) PREST_PG_USER PREST_PG_PASS PREST_PG_DATABASE PREST_PG_PORT (default 5432) PREST_JWT_KEY PREST_JWT_ALGO  TOML Optionally the pREST can be configured by TOML file.\n You can follow this sample and create your own prest.toml file and put this on the same folder that you run prest command.  migrations = \u0026quot;./migrations\u0026quot; [http] port = 6000 [jwt] key = \u0026quot;secret\u0026quot; algo = \u0026quot;HS256\u0026quot; [pg] host = \u0026quot;127.0.0.1\u0026quot; user = \u0026quot;postgres\u0026quot; pass = \u0026quot;mypass\u0026quot; port = 5432 database = \u0026quot;prest\u0026quot; [ssl] mode = \u0026quot;disable\u0026quot; sslcert = \u0026quot;./PATH\u0026quot; sslkey = \u0026quot;./PATH\u0026quot; sslrootcert = \u0026quot;./PATH\u0026quot;  Authorization  JWT middleware is enabled by default. To disable JWT need to set default to false.  [jwt] default = false  Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ   The HS256 algorithm is used by default.  The JWT algorithm can be specified by using either the environment variable PREST_JWT_ALGO or the algo parameter in the section [jwt] of the prest.toml configuration file.\nThe supported signing algorithms are:\n The HMAC signing method: HS256,HS384,HS512 The RSA signing method: RS256,RS384,RS512 The ECDSA signing method: ES256,ES384,ES512  SSL  There is 4 options to set on ssl mode:  \u0026quot;disable\u0026quot; - # no SSL (default) \u0026quot;require\u0026quot; - # Always SSL (skip verification) \u0026quot;verify-ca\u0026quot; - # Always SSL (verify that the certificate presented by the server was signed by a trusted CA) \u0026quot;verify-full\u0026quot; - # Always SSL (verify that the certification presented by the server was signed by a trusted CA and the server host name matches the one in the certificate)  Debug Mode  Set environment variable PREST_DEBUG or debug=true on top of prest.toml file.  PREST_DEBUG=true  Migrations --url and --path flags are optional if pREST configurations already set.\n# env var for migrations directory PREST_MIGRATIONS # create new migration file in path prest migrate --url driver://url --path ./migrations create migration_file_xyz # apply all available migrations prest migrate --url driver://url --path ./migrations up # roll back all migrations prest migrate --url driver://url --path ./migrations down # roll back the most recently applied migration, then run it again. prest migrate --url driver://url --path ./migrations redo # run down and then up command prest migrate --url driver://url --path ./migrations reset # show the current migration version prest migrate --url driver://url --path ./migrations version # apply the next n migrations prest migrate --url driver://url --path ./migrations next +1 prest migrate --url driver://url --path ./migrations next +2 prest migrate --url driver://url --path ./migrations next +n # roll back the previous n migrations prest migrate --url driver://url --path ./migrations next -1 prest migrate --url driver://url --path ./migrations next -2 prest migrate --url driver://url --path ./migrations next -n # go to specific migration prest migrate --url driver://url --path ./migrations goto 1 prest migrate --url driver://url --path ./migrations goto 10 prest migrate --url driver://url --path ./migrations goto v  "
},
{
	"uri": "https://postgres.rest/getting-started/new-database/",
	"title": "New database",
	"tags": [],
	"description": "",
	"content": "First you\u0026rsquo;ll need a running instance of PostgreSQL with a database, you can go to the PostgreSQL official documentation page on how to do that.\nNow that you have a database (instructions 1.1 through 1.3 Postgres\u0026rsquo; Getting Started tutorial linked above) you can follow the steps in the Pre-existing database page to configurate pREST according to pREST installation method you chose earlier.\n"
},
{
	"uri": "https://postgres.rest/getting-started/already-have-db/",
	"title": "Pre-existing database",
	"tags": [],
	"description": "",
	"content": " Even though there were four ways to install pREST there\u0026rsquo;s mostly two ways to run it.\n With the binary or homebrew or go get With Docker or Docker Compose  With the binary or homebrew or go get If you install pREST by downloading the binary or using Homebrew or using go get, you must pass the necessary variables binary as follows:\nPREST_PG_USER=postgres \\ PREST_PG_DATABASE=prest \\ PREST_PG_PORT=5432 \\ PREST_HTTP_PORT=3010 \\ prest # Binary installed  With docker Considering you already did the pull in the previous step:\ndocker run -e PREST_HTTP_PORT=3000 \\ -e PREST_PG_HOST=127.0.0.1 \\ -e PREST_PG_USER=postgres \\ -e PREST_PG_PASS=pass \\ prest/prest  or if use Docker Compose (there\u0026rsquo;s an example in the repository)\ndocker-compose up  For more details on how to configure and other environment variables got to Configurations\n"
},
{
	"uri": "https://postgres.rest/query-statements/",
	"title": "Query Statements",
	"tags": [],
	"description": "",
	"content": " Filter (WHERE) GET /DATABASE/SCHEMA/TABLE?FIELD=$eq.VALUE  Query Operators:\n   Name Description     $eq Matches values that are equal to a specified value.   $gt Matches values that are greater than a specified value.   $gte Matches values that are greater than or equal to a specified value.   $lt Matches values that are less than a specified value.   $lte Matches values that are less than or equal to a specified value.   $ne Matches all values that are not equal to a specified value.   $in Matches any of the values specified in an array.   $nin Matches none of the values specified in an array.   $null Matches if field is null.   $notnull Matches if field is not null.   $true Matches if field is true.   $nottrue Matches if field is not true.   $false Matches if field is false.   $notfalse Matches if field is not false.   $like Matches always cover the entire string.    Filter (WHERE) with JSONb field http://127.0.0.1:8000/DATABASE/SCHEMA/TABLE?FIELD-\u0026gt;\u0026gt;JSONFIELD:jsonb=VALUE (filter)  Select - GET http://127.0.0.1:8000/databases (show all databases) http://127.0.0.1:8000/databases?_count=* (count all databases) http://127.0.0.1:8000/databases?_renderer=xml (JSON by default) http://127.0.0.1:8000/schemas (show all schemas) http://127.0.0.1:8000/schemas?_count=* (count all schemas) http://127.0.0.1:8000/schemas?_renderer=xml (JSON by default) http://127.0.0.1:8000/tables (show all tables) http://127.0.0.1:8000/tables?_renderer=xml (JSON by default) http://127.0.0.1:8000/DATABASE/SCHEMA (show all tables, find by schema) http://127.0.0.1:8000/DATABASE/SCHEMA?_renderer=xml (JSON by default) http://127.0.0.1:8000/DATABASE/SCHEMA/TABLE (show all rows, find by database and table) http://127.0.0.1:8000/DATABASE/SCHEMA/TABLE?_select=column (select statement by columns) http://127.0.0.1:8000/DATABASE/SCHEMA/TABLE?_select=column[array id] (select statement by array colum) http://127.0.0.1:8000/DATABASE/SCHEMA/TABLE?_select=* (select all from TABLE) http://127.0.0.1:8000/DATABASE/SCHEMA/TABLE?_count=* (use count function) http://127.0.0.1:8000/DATABASE/SCHEMA/TABLE?_count=column (use count function) http://127.0.0.1:8000/DATABASE/SCHEMA/TABLE?_page=2\u0026amp;_page_size=10 (pagination, page_size 10 by default) http://127.0.0.1:8000/DATABASE/SCHEMA/TABLE?FIELD=VALUE (filter) http://127.0.0.1:8000/DATABASE/SCHEMA/TABLE?_renderer=xml (JSON by default) Select operations over a VIEW http://127.0.0.1:8000/DATABASE/SCHEMA/VIEW?_select=column (select statement by columns in VIEW) http://127.0.0.1:8000/DATABASE/SCHEMA/VIEW?_select=* (select all from VIEW) http://127.0.0.1:8000/DATABASE/SCHEMA/VIEW?_count=* (use count function) http://127.0.0.1:8000/DATABASE/SCHEMA/VIEW?_count=column (use count function) http://127.0.0.1:8000/DATABASE/SCHEMA/VIEW?_page=2\u0026amp;_page_size=10 (pagination, page_size 10 by default) http://127.0.0.1:8000/DATABASE/SCHEMA/VIEW?FIELD=VALUE (filter) http://127.0.0.1:8000/DATABASE/SCHEMA/VIEW?_renderer=xml (JSON by default)  Insert - POST http://127.0.0.1:8000/DATABASE/SCHEMA/TABLE  JSON DATA:\n{ \u0026quot;FIELD1\u0026quot;: \u0026quot;string value\u0026quot;, \u0026quot;FIELD2\u0026quot;: 1234567890 }  Update - PATCH/PUT Using query string to make filter (WHERE), example:\nhttp://127.0.0.1:8000/DATABASE/SCHEMA/TABLE?FIELD1=xyz  JSON DATA:\n{ \u0026quot;FIELD1\u0026quot;: \u0026quot;string value\u0026quot;, \u0026quot;FIELD2\u0026quot;: 1234567890, \u0026quot;ARRAYFIELD\u0026quot;: [\u0026quot;value 1\u0026quot;,\u0026quot;value 2\u0026quot;] }  Delete - DELETE Using query string to make filter (WHERE), example:\nhttp://127.0.0.1:8000/DATABASE/SCHEMA/TABLE?FIELD1=xyz  JOIN /DATABASE/SCHEMA/Table?_join=Type:Table2:Table.field:Operator:Table2.field  Parameters:\n Type (INNER, LEFT, RIGHT, OUTER) Table2 Table.field Operator ($eq, $lt, $gt, $lte, $gte) Table2.field  Using query string to JOIN tables, example:\n/DATABASE/SCHEMA/friends?_join=inner:users:friends.userid:$eq:users.id  Query Operators    Name Description     $eq Matches values that are equal to a specified value.   $gt Matches values that are greater than a specified value.   $gte Matches values that are greater than or equal to a specified value.   $lt Matches values that are less than a specified value.   $lte Matches values that are less than or equal to a specified value.   $ne Matches all values that are not equal to a specified value.   $in Matches any of the values specified in an array.   $nin Matches none of the values specified in an array.    DISTINCT To use DISTINCT clause with SELECT, follow this syntax _distinct=true.\nExamples:\n GET /DATABASE/SCHEMA/TABLE/?_distinct=true  ORDER BY Using ORDER BY in queries you must pass in GET request the attribute _order with fieldname(s) as value. For DESC order, use the prefix -. For multiple orders, the fields are separated by comma.\nExamples:\nASC GET /DATABASE/SCHEMA/TABLE/?_order=fieldname  DESC GET /DATABASE/SCHEMA/TABLE/?_order=-fieldname  Multiple Orders GET /DATABASE/SCHEMA/TABLE/?_order=fieldname01,-fieldname02,fieldname03 ## GROUP BY  We support this Group Functions:\n   name Use in request     SUM sum:field   AVG avg:field   MAX max:field   MIN min:field   MEDIAN median:field   STDDEV stddev:field   VARIANCE variance:field    Examples: GET /DATABASE/SCHEMA/TABLE/?_select=fieldname00,fieldname01\u0026amp;_groupby=fieldname01  Using Group Functions GET /DATABASE/SCHEMA/TABLE/?_select=fieldname00,sum:fieldname01\u0026amp;_groupby=fieldname01  Having support To use Having clause with Group By, follow this syntax:\n_groupby=fieldname-\u0026gt;\u0026gt;having:GROUPFUNC:FIELDNAME:CONDITION:VALUE-CONDITION  Example:\nGET /DATABASE/SCHEMA/TABLE/?_select=fieldname00,sum:fieldname01\u0026amp;_groupby=fieldname01-\u0026gt;\u0026gt;having:sum:fieldname01:$gt:500  "
},
{
	"uri": "https://postgres.rest/permissions/",
	"title": "Permissions",
	"tags": [],
	"description": "",
	"content": " Restrict mode In the prest.toml you can configure read/write/delete permissions of each table.\n[access] restrict = true # can access only the tables listed below  restrict = false: (default) the prest will serve in publish mode. You can write/read/delete everydata without configure permissions.\nrestrict = true: you need configure the permissions of all tables.\nTable permissions Example:\n[[access.tables]] name = \u0026quot;test\u0026quot; permissions = [\u0026quot;read\u0026quot;, \u0026quot;write\u0026quot;, \u0026quot;delete\u0026quot;] fields = [\u0026quot;id\u0026quot;, \u0026quot;name\u0026quot;]     attribute description     table Table name   permissions Table permissions. Options: read, write and delete   fields Fields permitted for select    Configuration example: prest.toml\n"
},
{
	"uri": "https://postgres.rest/executing-sql-scripts/",
	"title": "Executing SQL Scripts",
	"tags": [],
	"description": "",
	"content": " If need perform an advanced SQL, you can write some scripts SQL and access them by REST. These scripts are templates where you can pass by URL, values to them.\n_awesome_folder/example_ofpowerful.read.sql:\nSELECT * FROM table WHERE name = \u0026quot;{{.field1}}\u0026quot; OR name = \u0026quot;{{.field2}}\u0026quot;;  Get result:\nGET /_QUERIES/awesome_folder/example_of_powerful?field1=foo\u0026amp;field2=bar  To activate it, you need configure a location to scripts in your prest.toml like:\n[queries] location = /path/to/queries/  Scripts templates rules In your scripts, the fields to replace have to look like: field1 or field2 are examples\nSELECT * FROM table WHERE name = \u0026quot;{{.field1}}\u0026quot; OR name = \u0026quot;{{.field2}}\u0026quot;;  Script file must have a suffix based on http verb:\n   HTTP Verb Suffix     GET .read.sql   POST .write.sql   PUT, PATCH .update.sql   DELETE .delete.sql    In queries.location, you need given a folder to your scripts:\nqueries/ └── foo └── some_get.read.sql └── some_create.write.sql └── some_update.update.sql └── some_delete.delete.sql └── bar └── some_get.read.sql └── some_create.write.sql └── some_update.update.sql └── some_delete.delete.sql URLs to foo folder: GET /_QUERIES/foo/some_get?field1=bar POST /_QUERIES/foo/some_create?field1=bar PUT /_QUERIES/foo/some_update?field1=bar PATCH /_QUERIES/foo/some_update?field1=bar DELETE /_QUERIES/foo/some_delete?field1=bar URLs to bar folder: GET /_QUERIES/bar/some_get?field1=foo POST /_QUERIES/bar/some_create?field1=foo PUT /_QUERIES/bar/some_update?field1=foo PATCH /_QUERIES/bar/some_update?field1=foo DELETE /_QUERIES/bar/some_delete?field1=foo  Template functions  isSet return true if param is set.  SELECT * FROM table {{if isSet \u0026quot;field1\u0026quot;}} WHERE name = \u0026quot;{{.field1}}\u0026quot; {{end}} ;   defaultOrValue return param value or default value.  SELECT * FROM table WHERE name = '{{defaultOrValue \u0026quot;field1\u0026quot; \u0026quot;gopher\u0026quot;}}';   inFormat if value of param is an slice this function format to an IN SQL clause.  SELECT * FROM table WHERE name IN {{inFormat \u0026quot;field1\u0026quot;}};  "
},
{
	"uri": "https://postgres.rest/cors-support/",
	"title": "CORS Support",
	"tags": [],
	"description": "",
	"content": "In the prest.toml you can configurate the CORS allowed origin:\nExample:\n[cors] alloworigin = [\u0026quot;http://postgres.rest\u0026quot;, \u0026quot;http://foo.com\u0026quot;]  "
},
{
	"uri": "https://postgres.rest/case-studies/",
	"title": "Case studies",
	"tags": [],
	"description": "",
	"content": " Company and/or project uses pREST? Describe your use case here.\nThese are just a few companies and projects that are using (trusting) pREST.\nCompanies    Company Site     Nuveo nuveo.ai   Filmow filmow.com   Levpay levpay.com   uMov.me umov.me    "
},
{
	"uri": "https://postgres.rest/prest-as-web-framework/",
	"title": "Extending (framework)",
	"tags": [],
	"description": "",
	"content": " pREST was developed with the possibility of using it as a web framework, being able to use it based on its API, you create new endpoints and place middleware, adapting the pREST to your need.\nSample Hello World In order to create custom modules for pREST you need extends the router and register the custom new routes.\npackage main import ( \u0026quot;net/http\u0026quot; \u0026quot;github.com/prest/adapters/postgres\u0026quot; \u0026quot;github.com/prest/cmd\u0026quot; \u0026quot;github.com/prest/config\u0026quot; \u0026quot;github.com/prest/config/router\u0026quot; \u0026quot;github.com/prest/middlewares\u0026quot; ) func main() { config.Load() // Load Postgres Adapter postgres.Load() // Get pREST app middlewares.GetApp() // Get pPREST router r := router.Get() // Register custom routes r.HandleFunc(\u0026quot;/ping\u0026quot;, Pong).Methods(\u0026quot;GET\u0026quot;) // Call pREST cmd cmd.Execute() } func Pong(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\u0026quot;Pong!\u0026quot;)) }  "
},
{
	"uri": "https://postgres.rest/prest-as-web-framework/custom-middlewares/",
	"title": "Custom middlewares",
	"tags": [],
	"description": "",
	"content": " Using the previous sample we can create our middleware as a function and use that with GetApp() (godocs.org at prest/middlewares) that returns a *negroni.Negroni object.\npackage main import ( \u0026quot;log\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;github.com/prest/adapters/postgres\u0026quot; \u0026quot;github.com/prest/cmd\u0026quot; \u0026quot;github.com/prest/config\u0026quot; \u0026quot;github.com/prest/config/router\u0026quot; \u0026quot;github.com/prest/middlewares\u0026quot; ) func main() { config.Load() // Load Postgres Adapter postgres.Load() // Get pREST app n := middlewares.GetApp() // Register custom middleware n.UseFunc(CustomMiddleware) // Get pPREST router r := router.Get() // Register custom routes r.HandleFunc(\u0026quot;/ping\u0026quot;, Pong).Methods(\u0026quot;GET\u0026quot;) // Call pREST cmd cmd.Execute() } func Pong(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\u0026quot;Pong!\u0026quot;)) } func CustomMiddleware(w http.ResponseWriter, r *http.Request, next http.HandlerFunc) { log.Println(\u0026quot;Calling custom middleware\u0026quot;) next(w, r) }  Reorder middlewares It is possible to change the order of execution of middleware, for this we have the middlewares.MiddlewareStack (godocs.org at prest/middlewares) that receives negroni.Handler where you pass an array with the new order.\npackage main import ( \u0026quot;log\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;github.com/prest/adapters/postgres\u0026quot; \u0026quot;github.com/prest/cmd\u0026quot; \u0026quot;github.com/prest/config\u0026quot; \u0026quot;github.com/prest/config/router\u0026quot; \u0026quot;github.com/prest/middlewares\u0026quot; \u0026quot;github.com/urfave/negroni\u0026quot; ) func main() { config.Load() // Load Postgres Adapter postgres.Load() // Reorder middlewares middlewares.MiddlewareStack = []negroni.Handler{ negroni.Handler(negroni.NewRecovery()), negroni.Handler(negroni.NewLogger()), negroni.Handler(middlewares.HandlerSet()), negroni.Handler(negroni.HandlerFunc(CustomMiddleware)), } // Get pPREST router r := router.Get() // Register custom routes r.HandleFunc(\u0026quot;/ping\u0026quot;, Pong).Methods(\u0026quot;GET\u0026quot;) // Call pREST cmd cmd.Execute() } func Pong(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\u0026quot;Pong!\u0026quot;)) } func CustomMiddleware(w http.ResponseWriter, r *http.Request, next http.HandlerFunc) { log.Println(\u0026quot;Calling custom middleware\u0026quot;) next(w, r) }  "
},
{
	"uri": "https://postgres.rest/prest-as-web-framework/custom-middlewares/disable-jwt/",
	"title": "Disable JWT Middleware",
	"tags": [],
	"description": "",
	"content": " Using pREST as framework is common to need to do endpoint for authentication, and that endpoint cannot ask for JWT (header) because it will generate the token.\nCreate sub routes without JWT? package main import ( \u0026quot;encoding/json\u0026quot; \u0026quot;fmt\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;time\u0026quot; jwt \u0026quot;github.com/dgrijalva/jwt-go\u0026quot; \u0026quot;github.com/gorilla/mux\u0026quot; \u0026quot;github.com/prest/adapters/postgres\u0026quot; \u0026quot;github.com/prest/cmd\u0026quot; \u0026quot;github.com/prest/config\u0026quot; \u0026quot;github.com/prest/config/router\u0026quot; \u0026quot;github.com/prest/middlewares\u0026quot; \u0026quot;github.com/urfave/negroni\u0026quot; ) const authPrefix = \u0026quot;/auth\u0026quot; // Body data structure used to receive request type Body struct { Username string Password string } // Auth data structure used to return authentication token type Auth struct { Token string } func main() { // start pREST config config.Load() // pREST Postgres postgres.Load() // pREST routes r := router.Get() // Common middleware this application commonMiddleware := negroni.New( negroni.NewRecovery(), negroni.NewLogger(), ) // Auth routers authR := mux.NewRouter().PathPrefix(authPrefix).Subrouter().StrictSlash(true) authR.HandleFunc(\u0026quot;\u0026quot;, AuthHandler).Methods(\u0026quot;POST\u0026quot;) r.PathPrefix(authPrefix).Handler(commonMiddleware.With( negroni.Wrap(authR), )) // pREST middlewares middlewares.MiddlewareStack = []negroni.Handler{} r.PathPrefix(\u0026quot;/\u0026quot;).Handler(commonMiddleware.With( negroni.Handler(middlewares.JwtMiddleware(config.PrestConf.JWTKey)), )) // Call pREST cmd cmd.Execute() } // AuthHandler user authentication Handler func AuthHandler(w http.ResponseWriter, r *http.Request) { body := Body{} defer r.Body.Close() if err := json.NewDecoder(r.Body).Decode(\u0026amp;body); err != nil { http.Error(w, err.Error(), http.StatusBadRequest) return } tokenString, err := tokenGenerate(body.Username) if err != nil { http.Error(w, err.Error(), http.StatusBadRequest) } auth := Auth{ Token: tokenString, } w.WriteHeader(http.StatusOK) ret, _ := json.Marshal(auth) w.Write(ret) } // tokenGenerate return token JWT (simulating authentication) func tokenGenerate(Username string) (signedToken string, err error) { // Create the Claims claims := \u0026amp;jwt.StandardClaims{ ExpiresAt: time.Now().Add(time.Hour * 1).Unix(), Issuer: Username, } token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims) signedToken, err = token.SignedString([]byte(config.PrestConf.JWTKey)) return }  Test request curl -X POST -i -H \u0026quot;Content-Type: application/json\u0026quot; \\ -d '{\u0026quot;username\u0026quot;: \u0026quot;a\u0026quot;, \u0026quot;password\u0026quot;: \u0026quot;a\u0026quot;}' \\ http://127.0.0.1:3000/auth  "
},
{
	"uri": "https://postgres.rest/contribute/",
	"title": "Contribute",
	"tags": [],
	"description": "",
	"content": " Did you found an bug or you would like to suggest a new feature? I\u0026rsquo;m open for feedback. Please open a new issue and let me know what you think.\nYou\u0026rsquo;re also welcome to contribute with pull requests.\nRunning tests Clone the repository and create a test database and insert dummy data for specs.\nPREST_PG_HOST=127.0.0.1 PREST_PG_DATABASE=prest sh ./testdata/schema.sh  Run migrations on test database.\nPREST_PG_HOST=127.0.0.1 PREST_PG_DATABASE=prest sh ./testdata/migrations_test.sh  Run tests.\nPREST_PG_HOST=127.0.0.1 PREST_PG_DATABASE=prest sh ./testdata/test.sh  Contribution Guidelines Introduction This document explains how to contribute changes to the pREST project.\nBug reports Please search the issues on the issue tracker with a variety of keywords to ensure your bug is not already reported.\nIf unique, open an issue and answer the questions so we can understand and reproduce the problematic behavior.\nTo show us that the issue you are having is in pREST itself, please write clear, concise instructions so we can reproduce the behavior (even if it seems obvious). The more detailed and specific you are, the faster we can fix the issue. Check out How to Report Bugs Effectively.\nPlease be kind, remember that pREST comes at no cost to you, and you\u0026rsquo;re getting free help.\nDiscuss your design The project welcomes submissions but please let everyone know what you\u0026rsquo;re working on if you want to change or add something to the pREST repository.\nBefore starting to write something new for the pREST project, please file an issue.\nThis process gives everyone a chance to validate the design, helps prevent duplication of effort, and ensures that the idea fits inside the goals for the project and tools. It also checks that the design is sound before code is written; the code review tool is not the place for high-level discussions.\nTesting redux Before sending code out for review, run all the tests for the whole tree to make sure the changes don\u0026rsquo;t break other usage and keep the compatibility on upgrade. To make sure you are running the test suite exactly like we do, you should install the CLI for Travis CI, as we are using the server for continous testing.\nCode review Changes to pREST must be reviewed before they are accepted, no matter who makes the change even if it is an owner or a maintainer.\nPlease try to make your pull request easy to review for us. Please read the \u0026ldquo;How to get faster PR reviews\u0026rdquo; guide, it has lots of useful tips for any project you may want to contribute. Some of the key points:\n Make small pull requests. The smaller, the faster to review and the more likely it will be merged soon. Don\u0026rsquo;t make changes unrelated to your PR. Maybe there are typos on some comments, maybe refactoring would be welcome on a function\u0026hellip; but if that is not related to your PR, please make another PR for that. Split big pull requests into multiple small ones. An incremental change will be faster to review than a huge PR.  Sign your work The sign-off is a simple line at the end of the explanation for the patch. Your signature certifies that you wrote the patch or otherwise have the right to pass it on as an open-source patch. The rules are pretty simple: If you can certify DCO, then you just add a line to every git commit message:\nSigned-off-by: Thiago Avelino \u0026lt;avelino@email.com\u0026gt;  Please use your real name, we really dislike pseudonyms or anonymous contributions. We are in the open-source world without secrets. If you set your user.name and user.email git configs, you can sign your commit automatically with git commit -s.\nMaintainers To make sure every PR is checked, we have team maintainers. Every PR MUST be reviewed by at least two maintainers (or owners) before it can get merged. A maintainer should be a contributor of pREST and contributed at least 4 accepted PRs. A contributor should apply as a maintainer in the Gitter develop channel. The owners or the team maintainers may invite the contributor. A maintainer should spend some time on code reviews. If a maintainer has no time to do that, they should apply to leave the maintainers team and we will give them the honor of being a member of the advisors team. Of course, if an advisor has time to code review, we will gladly welcome them back to the maintainers team. If a maintainer is inactive for more than 3 months and forgets to leave the maintainers team, the owners may move him or her from the maintainers team to the advisors team.\nOwners Since pREST is maintained by Community, Nuveo (company that has idealized) does not provide professional support for pREST, to keep the development healthy we will elect three owners every year. All contributors may vote to elect up to three candidates, one of which will be the main owner, and the other two the assistant owners. When the new owners have been elected, the old owners will give up ownership to the newly elected owners. If an owner is unable to do so, the other owners will assist in ceding ownership to the newly elected owners.\nAfter the election, the new owners should proactively agree with our CONTRIBUTING requirements on the Gitter main channel. Below are the words to speak:\nI'm honored to having been elected an owner of pREST, I agree with [CONTRIBUTING](CONTRIBUTING.md). I will spend part of my time on pREST and lead the development of pREST.  Versions pREST has the master branch as a tip branch and has version branches such as v0.1. v0.1 is a release branch and we will tag v0.1.0 for binary download. If v0.1.0 has bugs, we will accept pull requests on the v0.1 branch and publish a v0.1.1 tag, after bringing the bug fix also to the master branch.\nSince the master branch is a tip version, if you wish to use pREST in production, please download the latest release tag version. All the branches will be protected via GitHub, all the PRs to every branch must be reviewed by two maintainers and must pass the automatic tests.\nCopyright Code that you contribute should use the standard copyright header:\n// Copyright 2017 The pREST Authors. All rights reserved. // Use of this source code is governed by a MIT-style // license that can be found in the LICENSE file.  Files in the repository contain copyright from the year they are added to the year they are last changed. If the copyright author is changed, just paste the header below the old one.\n"
},
{
	"uri": "https://postgres.rest/roadmap/",
	"title": "Roadmap",
	"tags": [],
	"description": "",
	"content": " Issues We have several issues for improvements and bug fixes, see below:\n"
},
{
	"uri": "https://postgres.rest/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://postgres.rest/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]